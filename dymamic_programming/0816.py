'''
이코테 다이나믹 프로그래밍

이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
구현 방식 : 탑다운 방식과 보텁업 방식


다이나믹 프로그래밍 조건
1.최적 부분 구조
    - 큰문제를 작은 문제로 나눌수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다
2.중복되는 부분 문제
    - 동일한 작은 무제를 반복적으로 해결해야 된다.
    
대표적인 문제
피보나치 수열
'''
#%%
def fibo(x):
    if x ==1 or x==2:
        return 1
    return fibo(x-1) + fibo(x-2)
print(fibo(1000))
# 수가 늘어지면 시간 복잡도가 높아진다.
#%%
'''
메모이제이션
한번 계산한 결과를 메모리 공간에 메모하는 기법이다.(이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념)
값을 기록해놓다는 점에서 캐싱이라고 함
'''
#%%
# 피보나치 수열 보텀업
d = [0] *1000
d[1]=1
d[2]=1
n = 999

for i in range(3 ,n+1):
    d[i] = d[i-1] + d[i-2]
    
print(d[n])
#%%

d = [0] *1000

def fibo(x):
    print('f(' + str(x)+ ")", end= " ")
    if x ==1 or x==2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

fibo(6)
#%%
'''
실전문제 3 개미전사
* 최소한 한 칸 이상 떨어진 식량창고를 약탈해야된다.
입력 조건 : 첫째 줄에 식량 창고의 개수 N이 주어진다. (3<N<100)
           둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 K가 주어진다.
출력 조건 : 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최대값을 출력 하시오

'''           
# %%
# 정수 N을 입력 받기

import sys
sys.stdin = open(
    'iceMaker.txt', 'r')

n = int(input())

# 모든 식량 정보 입력 받기

array = list(map(int, input.split()))

# 앞서 계산된 결과를 저장하기 위한 DP테이블 초기화
d = [0]*100

# 다이나믹 프로그래밍(Dynamic Programming) 진행(바텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])

for i in range(2,n):
    d[i] = max(d[i-1], d[i-2] + array[i])
    
# 계산된 결과 출력
print(d[n-1])
# %%
